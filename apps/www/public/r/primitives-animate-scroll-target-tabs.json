{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "primitives-animate-scroll-target-tabs",
  "type": "registry:ui",
  "title": "Scroll Target Tabs",
  "description": "A tabs component that scrolls to content sections instead of hiding/showing them. Sections remain visible and the active tab updates based on scroll position.",
  "dependencies": [
    "motion",
    "radix-ui",
    "class-variance-authority"
  ],
  "registryDependencies": [
    "@animate-ui/primitives-effects-highlight",
    "@animate-ui/lib-get-strict-context"
  ],
  "files": [
    {
      "path": "registry/primitives/animate/scroll-target-tabs/index.tsx",
      "content": "'use client';\n\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport { type HTMLMotionProps, motion, type Transition } from 'motion/react';\nimport * as React from 'react';\nimport { ScrollArea as ScrollAreaPrimitive } from 'radix-ui';\n\nimport {\n  Highlight,\n  HighlightItem,\n  type HighlightProps,\n} from '@/components/animate-ui/primitives/effects/highlight';\nimport { getStrictContext } from '@/lib/get-strict-context';\nimport { cn } from '@/lib/utils';\n\nconst scrollTargetTabVariants = cva(\n  'ring-sidebar-ring relative flex w-full items-center justify-center rounded-md px-3 py-1.5 text-center text-sm font-medium outline-hidden transition-colors focus-visible:ring-2',\n  {\n    variants: {\n      variant: {\n        primary:\n          'data-[state=active]:text-primary-foreground text-muted-foreground hover:text-primary',\n        accent:\n          'data-[state=active]:text-accent-foreground text-muted-foreground hover:text-accent-foreground',\n        secondary:\n          'data-[state=active]:text-secondary-foreground text-muted-foreground hover:text-foreground',\n      },\n    },\n    defaultVariants: {\n      variant: 'primary',\n    },\n  },\n);\n\nconst scrollTargetTabsHighlightVariants = cva('rounded-md', {\n  variants: {\n    variant: {\n      primary: 'bg-primary',\n      accent: 'bg-accent',\n      secondary: 'bg-secondary',\n    },\n  },\n  defaultVariants: {\n    variant: 'primary',\n  },\n});\n\ntype ScrollTargetTabsVariant = VariantProps<\n  typeof scrollTargetTabVariants\n>['variant'];\n\ntype ScrollTargetTabsContextType = {\n  activeValue: string;\n  setActiveValue: (value: string) => void;\n  registerSection: (value: string, element: HTMLElement | null) => void;\n  scrollToSection: (value: string) => void;\n  scrollOffset: number;\n  isProgrammaticScrollRef: React.MutableRefObject<boolean>;\n  variant: ScrollTargetTabsVariant;\n};\n\nconst [ScrollTargetTabsProvider, useScrollTargetTabs] =\n  getStrictContext<ScrollTargetTabsContextType>('ScrollTargetTabsContext');\n\ntype BaseScrollTargetTabsProps = React.ComponentProps<'div'> & {\n  children: React.ReactNode;\n  scrollOffset?: number;\n  variant?: ScrollTargetTabsVariant;\n};\n\ntype UncontrolledScrollTargetTabsProps = BaseScrollTargetTabsProps & {\n  defaultValue?: string;\n  value?: never;\n  onValueChange?: never;\n};\n\ntype ControlledScrollTargetTabsProps = BaseScrollTargetTabsProps & {\n  value: string;\n  onValueChange?: (value: string) => void;\n  defaultValue?: never;\n};\n\ntype ScrollTargetTabsProps =\n  | UncontrolledScrollTargetTabsProps\n  | ControlledScrollTargetTabsProps;\n\nfunction ScrollTargetTabs({\n  defaultValue,\n  value,\n  onValueChange,\n  scrollOffset = 10,\n  variant = 'primary',\n  children,\n  ...props\n}: ScrollTargetTabsProps) {\n  const [activeValue, setActiveValue] = React.useState<string>(\n    defaultValue ?? '',\n  );\n  const sectionsRef = React.useRef(new Map<string, HTMLElement>());\n  const isControlled = value !== undefined;\n\n  const currentValue = isControlled ? value : activeValue;\n\n  const handleSetActiveValue = React.useCallback(\n    (val: string) => {\n      if (!isControlled) {\n        setActiveValue(val);\n      }\n      onValueChange?.(val);\n    },\n    [isControlled, onValueChange],\n  );\n\n  const registerSection = React.useCallback(\n    (val: string, element: HTMLElement | null) => {\n      if (element) {\n        sectionsRef.current.set(val, element);\n      } else {\n        sectionsRef.current.delete(val);\n      }\n    },\n    [],\n  );\n\n  const isProgrammaticScrollRef = React.useRef(false);\n  const scrollCleanupRef = React.useRef<(() => void) | null>(null);\n\n  const scrollToSection = React.useCallback(\n    (val: string) => {\n      const element = sectionsRef.current.get(val);\n      if (!element) return;\n\n      // Update active value immediately FIRST to prevent flicker\n      handleSetActiveValue(val);\n\n      // Cancel any previous scroll detection from rapid clicking\n      if (scrollCleanupRef.current) {\n        scrollCleanupRef.current();\n        scrollCleanupRef.current = null;\n      }\n\n      // Set flag to block scroll boundary detection during programmatic scroll\n      isProgrammaticScrollRef.current = true;\n\n      // Get the scroll container (look for the ScrollArea viewport)\n      const scrollContainer = element.closest(\n        '[data-radix-scroll-area-viewport]',\n      );\n      if (!scrollContainer) {\n        // Fallback to native scrollIntoView\n        element.scrollIntoView({ behavior: 'smooth', block: 'start' });\n\n        // Use scrollend event if available, otherwise fallback to timeout\n        const clearFlagWithDebounce = () => {\n          // Add debounce buffer to prevent flicker at the end\n          setTimeout(() => {\n            isProgrammaticScrollRef.current = false;\n          }, 150);\n        };\n\n        if ('onscrollend' in window) {\n          window.addEventListener('scrollend', clearFlagWithDebounce, {\n            once: true,\n          });\n          scrollCleanupRef.current = () => {\n            window.removeEventListener('scrollend', clearFlagWithDebounce);\n          };\n        } else {\n          const timeoutId = setTimeout(clearFlagWithDebounce, 1000);\n          scrollCleanupRef.current = () => {\n            clearTimeout(timeoutId);\n          };\n        }\n        return;\n      }\n\n      // Calculate the scroll position with offset\n      const elementRect = element.getBoundingClientRect();\n      const containerRect = scrollContainer.getBoundingClientRect();\n      const scrollTop = scrollContainer.scrollTop;\n      const targetScrollTop =\n        scrollTop + elementRect.top - containerRect.top - scrollOffset;\n\n      // Smooth scroll using scrollTo\n      scrollContainer.scrollTo({\n        top: Math.max(0, targetScrollTop),\n        behavior: 'smooth',\n      });\n\n      // Detect when scroll animation completes\n      let lastScrollTop = scrollContainer.scrollTop;\n      let scrollStoppedTimer: number | null = null;\n      let safetyTimer: number | null = null;\n      let consecutiveStopCount = 0;\n      const maxWaitTime = 2000; // Maximum 2 seconds safety timeout\n      const scrollCheckInterval = 50; // Check every 50ms\n      const debounceDelay = 150; // Wait 150ms after scroll stops\n\n      const startTime = Date.now();\n\n      const clearFlagWithDebounce = () => {\n        // Clean up timers\n        if (scrollStoppedTimer !== null) {\n          clearInterval(scrollStoppedTimer);\n          scrollStoppedTimer = null;\n        }\n        if (safetyTimer !== null) {\n          clearTimeout(safetyTimer);\n          safetyTimer = null;\n        }\n\n        // Add debounce buffer to prevent flicker at the end\n        setTimeout(() => {\n          isProgrammaticScrollRef.current = false;\n          scrollCleanupRef.current = null;\n        }, debounceDelay);\n      };\n\n      // Use scrollend event if available (modern browsers)\n      if ('onscrollend' in scrollContainer) {\n        const handleScrollEnd = () => {\n          clearFlagWithDebounce();\n        };\n\n        scrollContainer.addEventListener('scrollend', handleScrollEnd, {\n          once: true,\n        });\n\n        // Still set a safety timeout\n        safetyTimer = window.setTimeout(clearFlagWithDebounce, maxWaitTime);\n\n        // Store cleanup function\n        scrollCleanupRef.current = () => {\n          scrollContainer.removeEventListener('scrollend', handleScrollEnd);\n          if (safetyTimer !== null) {\n            clearTimeout(safetyTimer);\n            safetyTimer = null;\n          }\n          isProgrammaticScrollRef.current = false;\n        };\n      } else {\n        // Fallback: Poll scroll position to detect when it stops changing\n        scrollStoppedTimer = window.setInterval(() => {\n          const currentScrollTop = scrollContainer.scrollTop;\n          const elapsed = Date.now() - startTime;\n\n          // More conservative stop detection: require 2 consecutive checks with < 2px movement\n          if (Math.abs(currentScrollTop - lastScrollTop) < 2) {\n            consecutiveStopCount++;\n            if (consecutiveStopCount >= 2) {\n              clearFlagWithDebounce();\n            }\n          } else {\n            consecutiveStopCount = 0;\n            lastScrollTop = currentScrollTop;\n          }\n\n          // Safety: force clear after max wait time\n          if (elapsed > maxWaitTime) {\n            clearFlagWithDebounce();\n          }\n        }, scrollCheckInterval);\n\n        // Store cleanup function\n        scrollCleanupRef.current = () => {\n          if (scrollStoppedTimer !== null) {\n            clearInterval(scrollStoppedTimer);\n            scrollStoppedTimer = null;\n          }\n          isProgrammaticScrollRef.current = false;\n        };\n      }\n    },\n    [scrollOffset, handleSetActiveValue],\n  );\n\n  const contextValue = React.useMemo<ScrollTargetTabsContextType>(\n    () => ({\n      activeValue: currentValue,\n      setActiveValue: handleSetActiveValue,\n      registerSection,\n      scrollToSection,\n      scrollOffset,\n      isProgrammaticScrollRef,\n      variant,\n    }),\n    [\n      currentValue,\n      handleSetActiveValue,\n      registerSection,\n      scrollToSection,\n      scrollOffset,\n      variant,\n    ],\n  );\n\n  return (\n    <ScrollTargetTabsProvider value={contextValue}>\n      <div data-slot=\"scroll-target-tabs\" {...props}>\n        {children}\n      </div>\n    </ScrollTargetTabsProvider>\n  );\n}\n\ntype ScrollTargetTabsHighlightProps = Omit<\n  HighlightProps,\n  'controlledItems' | 'value' | 'click'\n> & {\n  transition?: Transition;\n  containerClassName?: string;\n  boundsOffset?: Partial<{\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n  }>;\n};\n\nfunction ScrollTargetTabsHighlight({\n  transition = { type: 'spring', stiffness: 200, damping: 25 },\n  className,\n  ...props\n}: ScrollTargetTabsHighlightProps) {\n  const { activeValue, variant } = useScrollTargetTabs();\n\n  return (\n    <Highlight\n      data-slot=\"scroll-target-tabs-highlight\"\n      controlledItems\n      value={activeValue}\n      transition={transition}\n      click={false}\n      className={cn(scrollTargetTabsHighlightVariants({ variant }), className)}\n      {...props}\n    />\n  );\n}\n\ntype ScrollTargetTabsListProps = React.ComponentProps<'div'> & {\n  children: React.ReactNode;\n};\n\nfunction ScrollTargetTabsList({\n  className,\n  ...props\n}: ScrollTargetTabsListProps) {\n  return (\n    <div\n      role=\"tablist\"\n      data-slot=\"scroll-target-tabs-list\"\n      className={cn('flex items-center gap-1', className)}\n      {...props}\n    />\n  );\n}\n\ntype ScrollTargetTabProps = HTMLMotionProps<'button'> & {\n  value: string;\n  children: React.ReactNode;\n};\n\nfunction ScrollTargetTab({\n  value,\n  className,\n  onClick,\n  children,\n  ...props\n}: ScrollTargetTabProps) {\n  const { activeValue, scrollToSection, variant } = useScrollTargetTabs();\n  const isActive = activeValue === value;\n\n  const handleClick = React.useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(event);\n      scrollToSection(value);\n    },\n    [onClick, scrollToSection, value],\n  );\n\n  return (\n    <HighlightItem value={value} className=\"basis-0 min-w-0 flex-1\">\n      <motion.button\n        type=\"button\"\n        role=\"tab\"\n        aria-selected={isActive}\n        data-slot=\"scroll-target-tab\"\n        data-state={isActive ? 'active' : 'inactive'}\n        className={cn(\n          'cursor-pointer flex gap-1',\n          scrollTargetTabVariants({ variant }),\n          className,\n        )}\n        onClick={handleClick}\n        {...props}\n      >\n        {children}\n      </motion.button>\n    </HighlightItem>\n  );\n}\n\ntype ScrollTargetContentProps = React.ComponentPropsWithoutRef<\n  typeof ScrollAreaPrimitive.Root\n> & {\n  children: React.ReactNode;\n};\n\nfunction ScrollTargetContent({\n  className,\n  children,\n  ...props\n}: ScrollTargetContentProps) {\n  const { setActiveValue, scrollOffset, isProgrammaticScrollRef } =\n    useScrollTargetTabs();\n  const viewportRef = React.useRef<HTMLDivElement>(null);\n  const rafIdRef = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    const viewport = viewportRef.current;\n    if (!viewport) return;\n\n    // Function to determine which section is active based on scroll position\n    const updateActiveSection = () => {\n      // Ignore updates during programmatic scrolling\n      if (isProgrammaticScrollRef.current) {\n        return;\n      }\n\n      const sections = viewport.querySelectorAll<HTMLElement>(\n        '[data-scroll-target-section]',\n      );\n      if (sections.length === 0) return;\n\n      const scrollTop = viewport.scrollTop;\n      const threshold = scrollOffset;\n\n      // Find the last section whose top has crossed the threshold line\n      // (i.e., the section whose top is at or above the red line)\n      let activeSectionValue: string | null = null;\n\n      sections.forEach((section) => {\n        // Get the section's position relative to the scroll container\n        const sectionTop = section.offsetTop;\n\n        // Check if this section's top has crossed the threshold\n        if (sectionTop <= scrollTop + threshold) {\n          // This section has crossed the red line, so it's a candidate\n          const value = section.getAttribute('data-scroll-target-value');\n          if (value) {\n            activeSectionValue = value;\n          }\n        }\n      });\n\n      // Update the active value if we found a section\n      if (activeSectionValue) {\n        setActiveValue(activeSectionValue);\n      }\n    };\n\n    // Handle scroll with requestAnimationFrame for performance\n    const handleScroll = () => {\n      if (rafIdRef.current !== null) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n\n      rafIdRef.current = requestAnimationFrame(() => {\n        updateActiveSection();\n        rafIdRef.current = null;\n      });\n    };\n\n    // Set initial active section\n    updateActiveSection();\n\n    // Listen to scroll events\n    viewport.addEventListener('scroll', handleScroll, { passive: true });\n\n    return () => {\n      viewport.removeEventListener('scroll', handleScroll);\n      if (rafIdRef.current !== null) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n    };\n  }, [setActiveValue, scrollOffset, isProgrammaticScrollRef, children]);\n\n  return (\n    <ScrollAreaPrimitive.Root\n      data-slot=\"scroll-target-content\"\n      className={cn('overflow-hidden', className)}\n      {...props}\n    >\n      <ScrollAreaPrimitive.Viewport\n        ref={viewportRef}\n        className=\"size-full rounded-[inherit]\"\n      >\n        {children}\n      </ScrollAreaPrimitive.Viewport>\n      <ScrollAreaPrimitive.Corner />\n      <ScrollAreaPrimitive.Scrollbar\n        orientation=\"vertical\"\n        className=\"flex w-1.5 select-none data-[state=hidden]:animate-fd-fade-out\"\n      >\n        <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-fd-border\" />\n      </ScrollAreaPrimitive.Scrollbar>\n    </ScrollAreaPrimitive.Root>\n  );\n}\n\ntype ScrollTargetSectionProps = React.ComponentProps<'div'> & {\n  value: string;\n  children: React.ReactNode;\n};\n\nfunction ScrollTargetSection({\n  value,\n  className,\n  children,\n  ...props\n}: ScrollTargetSectionProps) {\n  const { registerSection, scrollOffset } = useScrollTargetTabs();\n  const sectionRef = React.useRef<HTMLDivElement>(null);\n\n  React.useEffect(() => {\n    registerSection(value, sectionRef.current);\n    return () => registerSection(value, null);\n  }, [value, registerSection]);\n\n  return (\n    <div\n      ref={sectionRef}\n      data-scroll-target-section\n      data-scroll-target-value={value}\n      data-slot=\"scroll-target-section\"\n      className={className}\n      style={{\n        scrollMarginTop: `${scrollOffset}px`,\n      }}\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport {\n  ScrollTargetTabs,\n  ScrollTargetTabsList,\n  ScrollTargetTabsHighlight,\n  ScrollTargetTab,\n  ScrollTargetContent,\n  ScrollTargetSection,\n  useScrollTargetTabs,\n  scrollTargetTabVariants,\n  scrollTargetTabsHighlightVariants,\n  type ScrollTargetTabsProps,\n  type ScrollTargetTabsListProps,\n  type ScrollTargetTabsHighlightProps,\n  type ScrollTargetTabProps,\n  type ScrollTargetContentProps,\n  type ScrollTargetSectionProps,\n  type ScrollTargetTabsContextType,\n  type ScrollTargetTabsVariant,\n};\n",
      "type": "registry:ui",
      "target": "components/animate-ui/primitives/animate/scroll-target-tabs.tsx"
    }
  ]
}